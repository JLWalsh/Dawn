import math # do nothing

module example {
    # register Rectangle as exported symbol in example table
    # ObjectSymbol(object definition)
    export object Rectangle {
        height: int,
        width: int
    }

    export object Circle {  # same as Rectangle
        radius: int
    }

    # register calculateArea as exported symbol in example table
    # FunctionSymbol(currentScope, function node)
    export calculateArea(rectangle: Rectangle): float {
        return rectangle.height * rectangle.width
    }

    # same as calculateArea(Rectangle)
    export calculateArea(circle: Circle): float {
        return math.pow(circle.radius, 2f) * math.PI
    }

} # pop env, pop module

main() { # register main as shadow in global module
   val rectangle = example.Rectangle { 10i, 20i } # lookup example.Rectangle symbol -> returns ObjectSymbol
                                                  # isExportLookup = !isParentOrSame(example, currentModule)
                                                  # check that types correspond
                                                  # define rectangle
   val circle = example.Circle { radius: 20i }    # same as ^

   print(example.calculateArea(rectangle))        # lookup example.calculateArea symbol -> returns FunctionSymbol[2]
                                                  # find matching FunctionSymbol for FunctionSymbol(Rectangle)
                                                  # execute that function with env = FunctionSymbol.env + args
   print(example.calculateArea(circle))
}
